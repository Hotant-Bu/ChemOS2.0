
# Generated by sila2.code_generator; sila2.__version__: 0.10.1
from __future__ import annotations


import os
import shutil
import subprocess
from chemspeed_operator_process.Utils import timestamp_datetime
import time
from typing import TYPE_CHECKING
import socket
import sys
import errno
from pathlib import Path
from typing import TYPE_CHECKING

from sila2.server import MetadataDict, ObservableCommandInstanceWithIntermediateResponses

from ..generated.chemspeedoperator import (
    Addbatch_IntermediateResponses,
    Addbatch_Responses,
    AddCharacterization_IntermediateResponses,
    AddCharacterization_Responses,
    ChangeProcedure_Responses,
    ChemSpeedOperatorBase,
)

if TYPE_CHECKING:
    from ..server import Server

LOG = "/Users/maozer/VSCode Projects/Sila2_Socket/chmspd_storage/chmspd.log"
OUTPUT: Path = "chmspd_output"
STORAGE: Path ='chmspd_storage'
BATCHFOLDER: Path = os.path.join(os.path.join(OUTPUT, "Synthesis"), "Batches_to_Make")
PROCEDUREDIR = os.path.join(os.path.join(OUTPUT, "Synthesis"), "Procedure")
COMPLETEDDIR = os.path.join(os.path.join(OUTPUT, "Synthesis"), "Completed_Batches")
HEADER_LENGTH = 10
IP = "127.0.0.1"
PORT = 65001
SOCKET_ID = 'sila2'


def isbusy():
    statusfile = os.path.join(OUTPUT, "status.txt")
    with open(statusfile, "r") as f:
        status = f.read()
    if status == "active":
        return True
    elif status == "inactive":
        return False
    else:
        raise ValueError

def run_synthesis_client(client_socket, instance, batchtoken, batchfile):
    while True:
        try:
            # Now we want to loop over received messages (there might be more than one) and print them
            while True:

                # Receive our "header" containing username length, it's size is defined and constant
                username_header = client_socket.recv(HEADER_LENGTH)

                # If we received no data, server gracefully closed a connection, for example using socket.close() or socket.shutdown(socket.SHUT_RDWR)
                if not len(username_header):
                    print('Connection closed by the server')
                    sys.exit()

                # Convert header to int value
                username_length = int(username_header.decode('utf-8').strip())

                # Receive and decode username
                username = client_socket.recv(username_length).decode('utf-8')

                # Now do the same for message (as we received username, we received whole message, there's no need to check if it has any length)
                message_header = client_socket.recv(HEADER_LENGTH)
                message_length = int(message_header.decode('utf-8').strip())
                message = client_socket.recv(message_length).decode('utf-8')

                # Print message
                print(f'{username} > {message}')

                
                instance.send_intermediate_response(Addbatch_IntermediateResponses(message, "operations"))
                if message == f'Synthesis: Synthesis of batch {batchtoken} has been completed':
                    # with open(os.path.join(COMPLETEDDIR, f"{batchtoken}.json"), 'r') as file:
                    #     data = file.read()
                    # instance.send_intermediate_response(Addbatch_IntermediateResponses('silasocket_operations', f"{data}"))

                    with open(os.path.join(COMPLETEDDIR, f"{batchtoken}_Operations.json"), 'r') as file:
                        data = file.read()
                    instance.send_intermediate_response(Addbatch_IntermediateResponses('silasocket_operations', f"{data}"))

                    return "synthesis comnplete"

        except IOError as e:
            # This is normal on non blocking connections - when there are no incoming data error is going to be raised
            # Some operating systems will indicate that using AGAIN, and some using WOULDBLOCK error code
            # We are going to check for both - if one of them - that's expected, means no incoming data, continue as normal
            # If we got different error code - something happened
            if e.errno != errno.EAGAIN and e.errno != errno.EWOULDBLOCK:
                print('Reading error: {}'.format(str(e)))
                sys.exit()

            # We just did not receive anything
            continue

        except Exception as e:
            # Any other exception - something happened, exit
            print('Reading error: '.format(str(e)))
            sys.exit()

def run_characterization_client(client_socket, instance, identifier, opsfile):
    while True:
        try:
            # Now we want to loop over received messages (there might be more than one) and print them
            while True:

                # Receive our "header" containing username length, it's size is defined and constant
                username_header = client_socket.recv(HEADER_LENGTH)

                # If we received no data, server gracefully closed a connection, for example using socket.close() or socket.shutdown(socket.SHUT_RDWR)
                if not len(username_header):
                    print('Connection closed by the server')
                    sys.exit()

                # Convert header to int value
                username_length = int(username_header.decode('utf-8').strip())

                # Receive and decode username
                username = client_socket.recv(username_length).decode('utf-8')

                # Now do the same for message (as we received username, we received whole message, there's no need to check if it has any length)
                message_header = client_socket.recv(HEADER_LENGTH)
                message_length = int(message_header.decode('utf-8').strip())
                message = client_socket.recv(message_length).decode('utf-8')

                # Print message
                print(f'{username} > {message}')
                instance.send_intermediate_response(AddCharacterization_IntermediateResponses(message, "operations"))
                if message == f'Characterization: Injection characterization_1st started for {identifier}':
                    #data = json.load(opsfile)[identifier]
                    instance.send_intermediate_response(AddCharacterization_IntermediateResponses(message, "operations"))
                    #instance.send_intermediate_response(AddCharacterization_IntermediateResponses("charaterization operations", f"{data}"))
                    return "Product injected into HPLC"

        except IOError as e:
            # This is normal on non blocking connections - when there are no incoming data error is going to be raised
            # Some operating systems will indicate that using AGAIN, and some using WOULDBLOCK error code
            # We are going to check for both - if one of them - that's expected, means no incoming data, continue as normal
            # If we got different error code - something happened
            if e.errno != errno.EAGAIN and e.errno != errno.EWOULDBLOCK:
                print('Reading error: {}'.format(str(e)))
                sys.exit()

            # We just did not receive anything
            continue

        except Exception as e:
            # Any other exception - something happened, exit
            print('Reading error: '.format(str(e)))
            sys.exit()
